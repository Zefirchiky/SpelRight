use core::mem::size_of_val;
use std::{fs, path::Path};

use indexmap::IndexSet;
use rayon::prelude::*;


pub struct SpellChecker {
    words: IndexSet<&'static str>,
}

impl SpellChecker {
    pub fn new() -> Self {
        Self {
            words: IndexSet::default(),
        }
    }
    
    pub fn load_dictionary(&mut self, dict: &Vec<&'static str>) {
        self.words.reserve_exact(dict.len() + 10);
        self.words.par_extend(dict);
        println!("dict size: {} mb", {
            let mut size = 0;
            println!("{}", size_of_val(*self.words.first().unwrap()));
            for word in &self.words {
                size += size_of_val(word);
            }
            size as f64 / 1024. / 1024.
        });
    }
    
    pub fn add(&mut self, word: String) {
        self.words.insert(Box::leak(Box::new(word)));
    }

    pub fn check(&self, word: &str) -> bool {
        self.words.contains(word.to_lowercase().as_str())
    }

    /// Suggest words that are similar to the given word.
    ///
    /// # Args
    ///
    /// * `word`: The word to suggest similar words for.
    /// * `take_first_x`: The number of suggestions to take from the result.
    ///
    /// # Returns
    ///
    /// A vector of words that are similar to the given word. If `take_first_x` is 0,
    /// all suggestions are returned. Otherwise, only the first `take_first_x` suggestions
    /// are returned.
    pub fn suggest(&self, word: &str, take_first_x: usize) -> Vec<&'static str> {
        let word = word.to_lowercase();

        if let Some(&exact_word) = self.words.get(word.as_str()) {
            return vec![exact_word];
        }

        let bcomp = rapidfuzz::distance::levenshtein::BatchComparator::new(word.chars());
        let mut result: Vec<(&'static str, usize)> = self
            .words
            .par_iter()
            .filter(|&&dict_word| ((dict_word.len() as i32 - word.len() as i32).abs()) <= 2)
            .filter_map(|&dict_word| {
                let dist = bcomp.distance(dict_word.chars());
                if dist <= 2 {
                    Some((dict_word, dist))
                } else {
                    None
                }
            })
            .collect();

        if result.len() > 1 {
            result.par_sort_by_key(|(_, dist)| *dist);
        }
    
        if take_first_x == 0 {
            result.into_iter().map(|(word, _)| word).collect()
        } else {
            result.into_iter().take(take_first_x).map(|(word, _)| word).collect()
        }
    }

    /// Returns a vector of vectors of strings containing the suggestions for each of the given words.
    ///
    /// The suggestions are generated by computing the Levenshtein distance between each of the given words and all the words in the dictionary.
    /// The results are sorted by the distance in ascending order.
    ///
    /// If the given word is in the dictionary, only that word is returned.
    ///
    /// If take_first_x is 0, all suggestions are returned.
    /// Otherwise, only the first take_first_x suggestions are returned.
    pub fn batch_suggest(&self, words: &[&str], take_first_x: usize) -> Vec<Vec<&'static str>> {
        words.iter().map(|word| self.suggest(word, take_first_x)).collect()
    }

    /// Returns a vector of vectors of strings containing the suggestions for each of the given words.
    /// 
    /// The suggestions are generated by computing the Levenshtein distance between each of the given words and all the words in the dictionary.
    /// The results are sorted by the distance in ascending order.
    /// 
    /// If the given word is in the dictionary, only that word is returned.
    /// 
    /// If take_first_x is 0, all suggestions are returned.
    /// Otherwise, only the first take_first_x suggestions are returned.
    /// 
    /// This is a parallelized version of batch_suggest.
    pub fn batch_par_suggest(&self, words: &[&str], take_first_x: usize) -> Vec<Vec<&'static str>> {
        words.par_iter().map(|word| self.suggest(word, take_first_x)).collect()
    }
}

pub fn load_words_dict<T: AsRef<Path>>(file: T) -> Result<Vec<&'static str>, Box< dyn std::error::Error>> {
    let content = fs::read_to_string(file)?;
    let words: Vec<&'static str> = Box::leak(Box::new(content)).par_lines().collect();
    println!("Content vec {} mb", {
        let mut size = 0;
        for word in &words {
            size += word.len();
        }
        size as f64 / 1024. / 1024.
    });

    Ok(words)
}